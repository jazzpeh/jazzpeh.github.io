
var documents = [{
    "id": 0,
    "url": "/404.html",
    "title": "404",
    "body": "404 Page not found!Please use the search bar from the bottom left or visit our homepage! "
    }, {
    "id": 1,
    "url": "/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 2,
    "url": "/",
    "title": "Home",
    "body": "                                    Post-order Traversal                                    Post-order Traversal              :       Lets look at the 4 options to traverse a binary tree::                                                                               Jazz                20 May 2020                                                                In-order Traversal                                    In-order Traversal              :       Lets look at the 4 options to traverse a binary tree::                                                                               Jazz                19 May 2020                                                                Pre-order Traversal                                    Pre-order Traversal              :       Lets look at the 4 options to traverse a binary tree::                                                                               Jazz                18 May 2020                                                                Number of paths to reach last cell                                    Number of paths to reach last cell              :       Given a (n,n) 2D matrix and a total cost to reach the destination cell, we need to start from (0,0) cell and go till (n-1,n-1) cell. Assuming that each cell. . . :                                                                               Jazz                12 May 2020                                                                Min cost to reach last cell in 2D Array                                    Min cost to reach last cell in 2D Array              :       Given a (n,n) 2D matrix, we need to start from (0,0) cell and go till (n-1,n-1) cell. Assuming that each cell has a cost associated and we can only go. . . :                                                                               Jazz                12 May 2020                                                                Longest Palindromic Substring                                    Longest Palindromic Substring              :       Given a string S, we need to find length of its Longest Palindromic Substring. Palindrome is a string that reads the same backwards as well as forward and can be. . . :                                                                               Jazz                12 May 2020                                   &laquo;        1        2        3        4       &raquo; "
    }, {
    "id": 3,
    "url": "/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 4,
    "url": "/page2/",
    "title": "Home",
    "body": "  {% for post in paginator. posts %}    {% include postbox. html %}  {% endfor %}  {% include pagination. html %}"
    }, {
    "id": 5,
    "url": "/page3/",
    "title": "Home",
    "body": "  {% for post in paginator. posts %}    {% include postbox. html %}  {% endfor %}  {% include pagination. html %}"
    }, {
    "id": 6,
    "url": "/page4/",
    "title": "Home",
    "body": "  {% for post in paginator. posts %}    {% include postbox. html %}  {% endfor %}  {% include pagination. html %}"
    }, {
    "id": 7,
    "url": "/post-order-traversal/",
    "title": "Post-order Traversal",
    "body": "2020/05/20 - Lets look at the 4 options to traverse a binary tree:  Depth First Search     Pre-order   In-order   Post-order    Breadth First Search     Level-order   In this post, let’s explore Post-order traversal. Visualise how it traverse: We first visit the Left Subtree, then the Right subtree and lastly, the Root.         20       /  \     /     \    100     3   /   \   /  \  50   15 250  35 /222r = rootlt = left subtreert = right subtree1. (lt)(rt)r2. ((lt)(rt)r)(rt)203. ((lt)(rt)100)(rt)204. (((lt)(rt)r)(rt)100)(rt)205. (((lt)(rt)50)(rt)100)(rt)206. (((222)50)(rt)100)(rt)207. (((222)50)(15)100)(rt)208. (((222)50)(15)100)((lt)(rt)r)209. (((222)50)(15)100)((lt)(rt)3)2010. (((222)50)(15)100)((250)(35)3)20Answer: 222, 50, 15, 100, 250, 35, 3, 20Code Algorithm: Here’s the code example to implmenent a Post-ordertraversal. # Definition for binary node. # class BinaryNode:#   def __init__(self, val=0, left=None, right=None):#     self. val = val#     self. left = left#     self. right = rightdef post_order(root: BinaryNode) -&gt; None: if not root:  throw Error() else:  post_order(root. left)  post_order(root. right)  print(root. val)"
    }, {
    "id": 8,
    "url": "/in-order-traversal/",
    "title": "In-order Traversal",
    "body": "2020/05/19 - Lets look at the 4 options to traverse a binary tree:  Depth First Search     Pre-order   In-order   Post-order    Breadth First Search     Level-order   In this post, let’s explore In-order traversal. Visualise how it traverse: We first visit the Left Subtree, then the Root and lastly, the Right subtree.         20       /  \     /     \    100     3   /   \   /  \  50   15 250  35 /222r = rootlt = left subtreert = right subtree1. (lt)r(rt)2. (lt)20(rt)3. ((lt)r(rt))20(rt)4. ((lt)100(rt))20(rt)5. (((lt)r(rt))100(rt))20(rt)6. (((lt)50(rt))100(rt))20(rt)7. (((222)50)100(rt))20(rt)8. (((222)50)100(15))20(rt)9. (((222)50)100(15))20((lt)r(rt))10. (((222)50)100(15))20((lt)3(rt))11. (((222)50)100(15))20((250)3(35))Answer: 222, 50, 100, 15, 20, 250, 3, 35Code Algorithm: Here’s the code example to implmenent a In-ordertraversal. # Definition for binary node. # class BinaryNode:#   def __init__(self, val=0, left=None, right=None):#     self. val = val#     self. left = left#     self. right = rightdef in_order(root: BinaryNode) -&gt; None: if not root:  throw Error() else:  in_order(root. left)  print(root. val)  in_order(root. right)"
    }, {
    "id": 9,
    "url": "/pre-order-traversal/",
    "title": "Pre-order Traversal",
    "body": "2020/05/18 - Lets look at the 4 options to traverse a binary tree:  Depth First Search     Pre-order   In-order   Post-order    Breadth First Search     Level-order   In this post, let’s explore Pre-order traversal. Visualise how it traverse: We first visit the Root, then the Left Subtree and lastly, the Right subtree.         20       /  \     /     \    100     3   /   \   /  \  50   15 250  35 /222r = rootlt = left subtreert = right subtree1. r(lt)(rt)2. 20(lt)(rt)3. 20(r(lt)(rt))(rt)4. 20(100(lt)(rt))(rt)5. 20(100(r(lt)(rt))(rt))(rt)6. 20(100(50(lt)(rt))(rt))(rt)7. 20(100(50(222)(rt))(rt))(rt)8. 20(100(50(222))(rt))(rt)9. 20(100(50(222))(15))(rt)10. 20(100(50(222))(15))(3(lt)(rt))11. 20(100(50(222))(15))(3(250)(rt))12. 20(100(50(222))(15))(3(250)(35))Answer: 20, 100, 50, 222, 15, 3, 250, 35Code Algorithm: Here’s the code example to implmenent a Pre-ordertraversal. # Definition for binary node. # class BinaryNode:#   def __init__(self, val=0, left=None, right=None):#     self. val = val#     self. left = left#     self. right = rightdef pre_order(root: BinaryNode) -&gt; None: if not root:  throw Error() else:  print(root. val)  pre_order(root. left)  pre_order(root. right)"
    }, {
    "id": 10,
    "url": "/number-of-paths-to-reach-last-cell/",
    "title": "Number of paths to reach last cell",
    "body": "2020/05/12 - Given a (n,n) 2D matrix and a total cost to reach the destination cell, we need to start from (0,0) cell and go till (n-1,n-1) cell. Assuming that each cell has a cost associated and we can only go right or down from current cell. Find the number of ways to reach destination cell with given total cost. Example-----------input: [ [ 4, 7, 1, 6 ], [ 5, 7, 3, 9 ], [ 3, 2, 1, 2 ], [ 7, 1, 6, 3 ]]cost: 25output: 2Explanation: 4-&gt;7-&gt;1-&gt;3-&gt;1-&gt;6-&gt;3 and 4-&gt;5-&gt;7-&gt;4-&gt;1-&gt;2-&gt;3Solution: This problem can be solved by applying Divide and Conquer to break down the problem into smaller subproblems. Thus, by solving these subproblems, we will arrive at our final answer. Let’s try to derive the subproblems. 1. f(2, 3, 22) -&gt; e. g. 5 ways ---|---sum2. f(3, 2, 22) -&gt; e. g. 4 ways ---|We shall start by looking at the last cell. In order to reach the last cell, we know that the traversal can only go right or down. Therefore, it meant that from the last cell, we can only go left or up. If the given cost is 25, we know that in order to reach the last cell which has a value of 3, the cell before need to only have a value of 22. Hence, if we can solve these, by summing them up we can then get our final answer. Code Algortihm: def num_paths(mat: List[List[int]], row: int, col: int, cost: int) -&gt; int: if cost &lt; 0:  return 0 remaining_cost: int = cost - mat[row][col] if row == 0 and col == 0:  return 1 if remaining_cost == 0 else 0 if row == 0:  return num_paths(mat, 0, col-1, remaining_cost) if col == 0:  return num_paths(mat, row-1, 0, remaining_cost) from_up: int = num_paths(mat, row-1, col, remaining_cost) from_left: int = num_paths(mat, row, col-1, remaining_cost) return from_up + from_leftOptimisation: Let’s look at the an example of the recursion tree see if we need to optimise this solution.                   p(3,3,25)                 /     \               /        \             /           \           p(2,3,22)         p(3,2,22)          /    \         /    \         /       \      p(2,2,20)  p(3,1,20)      p(1,3,20)     p(2,2,20)   /   \      /     \         p(1,2,19) p(2,1,19)     /       \   p(0,3,11)    p(1,2,11)   |        /    \   |-p(0,2,5)  p(0,2,8)  p(1,1,8)   |-p(0,3,4)  |          |-p(0,1,7)We are computing a new of the subproblems more than once such as p(2,2,20). We can then apply Dynamic Programming to optimise the solution. dp = {}def num_paths(mat: List[List[int]], row: int, col: int, cost: int) -&gt; int: if cost &lt; 0:  return 0 remaining_cost: int = cost - mat[row][col]  if row == 0 and col == 0:  return 1 if remaining_cost == 0 else 0 if (row, col, cost) not in dp:  if row == 0:   dp[row, col, cost] = num_paths_topdown(mat, 0, col-1, remaining_cost)  elif col == 0:   dp[row, col, cost] = num_paths_topdown(mat, row-1, 0, remaining_cost)  else:   from_up: int = num_paths_topdown(mat, row-1, col, remaining_cost)   from_left: int = num_paths_topdown(mat, row, col-1, remaining_cost)   dp[row, col, cost] = from_up + from_left return dp[row, col, cost]Bottom Up Approach: We can now then apply some reverse engineer to use the Bottom Up Approach (also known as Tabulation). Firstly, let’s start from looking at the Top Down Approach using a matrix table.               C1    C2    C3    C4              R1    ?    R1C1    R1C2    R1C3          R2    R1C1    R1C2+R2C1    R1C3+R2C2    R1C4+R2C3          R3    R2C1    R2C2+R3C1    R2C3+R3C2    R2C4+R3C3          R4    R3C1    R3C2+R4C1    R3C3+R4C2    R3C4+R4C3      For our top down approach, in order to get the solution at R1C1, we entered from R4C4 and worked our way up, checking the cost as we go along. Hence, in order to perform bottom up approach. However, this is a tricky scenario because typically at our base condition, we have a value, instead, at R1C1 we are dependent on the other cells for the remaining cost. Hence, we will need to apply the same format, starting from the bottom and working our way up to R1C1 with a twist. I will cover it in the next time as it is going to be long post by itself. "
    }, {
    "id": 11,
    "url": "/min-cost-to-reach-last-cell-in-2d-array/",
    "title": "Min cost to reach last cell in 2D Array",
    "body": "2020/05/12 - Given a (n,n) 2D matrix, we need to start from (0,0) cell and go till (n-1,n-1) cell. Assuming that each cell has a cost associated and we can only go right or down from current cell, find the traversal in minimum cost. Example-----------input: [ [ 4, 7, 8, 6, 4 ], [ 6, 7, 3, 9, 2 ], [ 3, 8, 1, 2, 4 ], [ 7, 1, 7, 3, 7 ], [ 2, 9, 8, 9, 3 ]]output: 36Explanation: 4-&gt;6-&gt;7-&gt;3-&gt;1-&gt;2-&gt;3-&gt;3Solution: This problem can be solved by applying Divide and Conquer to break down the problem into smaller subproblems. Thus, by solving these subproblems, we will arrive at our final answer. Let’s try to derive the subproblems. 1. min of going right f(0, 1) and going down f(1, 0)2. if we reach the end of the right cell, we can only go down3. if we reach the end of the bottom cell, we can only go rightCode Algortihm: def min_cost(mat: List[List[int]], row: int, col: int) -&gt; int: if row &gt; len(mat)-1 or col &gt; len(mat[0])-1:  return sys. maxsize if row == len(mat)-1 and col == len(mat[0])-1:  return mat[row][col] right: int = min_cost(mat, row, col+1) down: int = min_cost(mat, row+1, col) return mat[row][col] + min(right, down)Optimisation: Let’s look at the an example of the recursion tree see if we need to optimise this solution.                   min(0,0)                 /     \               /        \             /           \           min(0,1)          min(1,0)          /    \         /    \         /       \      min(1,1)   min(2,0)       min(0,2)     min(1,1)   /   \      /     \         min(1,2) min(2,1)     /       \    min(0,3)    min(1,2)   /    \    /    \min(0,4)  min(1,3) min(1,3) min(2,2)We are computing a new of the subproblems more than once such as min(1,1) and min(1,2). We can then apply Dynamic Programming to optimise the solution. dp = {}def min_cost(mat: List[List[int]], row: int, col: int) -&gt; int: if row &gt; len(mat)-1 or col &gt; len(mat[0])-1:  return sys. maxsize if row == len(mat)-1 and col == len(mat[0])-1:  return mat[row][col] if (row, col) not in dp:  right: int = min_cost(mat, row, col+1)  down: int = min_cost(mat, row+1, col)  dp[row, col] = mat[row][col] + min(right, down) return dp[row, col]Bottom Up Approach: We can now then apply some reverse engineer to use the Bottom Up Approach (also known as Tabulation). Firstly, let’s start from looking at the Top Down Approach using a matrix table.               C1    C2    C3    C4    C5              R1    min(R1C2,R2C1)+4    min(R1C3,R2C2)+7    min(R1C4,R2C4)+8    min(R1C5,R2C5)+6    R2C5+4          R2    min(R2C2,R3C1)+6    min(R2C3,R3C2)+7    min(R2C4,R3C3)+3    min(R2C5,R3C4)+9    R3C5+2          R3    min(R3C2,R4C1)+3    min(R3C3,R4C2)+8    min(R3C4,R4C3)+1    min(R3C5,R4C4)+2    R4C5+4          R4    min(R4C2,R5C1)+7    min(R4C3,R5C2)+1    min(R4C4,R5C3)+7    min(R4C5,R5C4)+3    R5C5+7          R5    R5C2+2    R5C3+9    R5C4+8    R5C5+9    3      For top down approach, we enter from R1C1 and then recusively all the way to R5C5 to hit our base condition which is the first independent value. Hence, for bottom up approach, we can the solve R5C5 cell first, then the R5 row and then make our way up to R1C1 to get our final answer. def min_cost(mat: List[List[int]]) -&gt; int: dp = {} for row in range(len(mat)-1, -1, -1):  for col in range(len(mat[0])-1, -1, -1):   if row == len(mat)-1 and col == len(mat[0])-1:    dp[row, col] = mat[row][col]   elif row == len(mat)-1:    dp[row, col] = mat[row][col] + dp[row, col+1]   elif col == len(mat[0])-1:    dp[row, col] = mat[row][col] + dp[row+1, col]   else:    dp[row, col] = mat[row][col] + min(dp[row+1, col], dp[row, col+1]) return dp[0,0]"
    }, {
    "id": 12,
    "url": "/longest-palindromic-substring/",
    "title": "Longest Palindromic Substring",
    "body": "2020/05/12 - Given a string S, we need to find length of its Longest Palindromic Substring. Palindrome is a string that reads the same backwards as well as forward and can be odd or even length. A substring is a contiguous sequence of characters within a string. Example 1-----------s:  ABCYRCFBTUA output: 1Explanation:  ABCYRCFBTUA  =&gt;  A        ^Example 2-----------s:  ABCCBUA output: 4Explanation:  ABCCBUA  =&gt;  BCCB         ^^^^Example 3-----------s:  MQADASM output: 3Explanation:  MQADASM  =&gt;  ADA         ^^^Solution: This problem can be solved by applying Divide and Conquer to break down the problem into smaller subproblems. Thus, by solving these subproblems, we will arrive at our final answer. Let’s try to derive the subproblems. If the first and last character matches: 2 + f(2,6) only if the remaining characters are palindrome ---|--- maxIf it doesn't match: max of [0 + f(2,7)] or [0 + f(1,6)]                      ---|For palindrome, the first and last character should be the same so that it reads the same from the front and the back. Hence, to achive optimal substructure, if the first and last character matches, our answer increases by 2 and we move on to the next characters, hence, 2 + f(2,6). However, if the remaining characters are not palindrome, we should not increase our answer by 2 since we are looking for substring which needs to be contiguous. If it doesn’t match, we should then attempt to see if the next characters on both side matches and get the max value from it. Therefore, max of [0 + f(2,7)] or [0 + f(1,6)]. Code Algortihm: def lps(s: str, start: int, end: int) -&gt; int:  if start &gt; end:   return 0  if start == end:   return 1  count1 = 0  if s[start] == s[end]:   remainingLen = end - start - 1   if lps(s, start+1, end-1) == remainingLen:    count1 = 2 + remainingLen  count2 = lps(s, start, end-1)  count3 = lps(s, start+1, end)  return max(count1, count2, count3)Optimisation: Let’s look at the an example of the recursion tree see if we need to optimise this solution.         lps(0,8)  /        |        \ lps(1,7)    lps(1,8)    lps(0,7) |        |        | |-lps(2,6)    |-lps(2,7)    |-lps(1,6) |-lps(2,7)    |-lps(2,8)    |-lps(1,7) |-lps(1,6)    |-lps(1,7)    |-lps(0,6)We are computing a new of the subproblems more than once such as lps(1,7). We can then apply Dynamic Programming to optimise the solution. Top Down Approach: We will start off by applying Top Down Approach (also known as Memoization). dp = {}def lps(s: str, start: int, end: int) -&gt; int:  if start &gt; end:   return 0  if start == end:   return 1  if (start, end) not in dp:   count1 = 0   if s[start] == s[end]:    remainingLen = end - start - 1    if lps(s, start+1, end-1) == remainingLen:     count1 = 2 + remainingLen   count2 = lps(s, start, end-1)   count3 = lps(s, start+1, end)   dp[start, end] = max(count1, count2, count3)  return dp[start, end]Bottom Up Approach: We can now then apply some reverse engineer to use the Bottom Up Approach (also known as Tabulation). Firstly, let’s start from looking at the Top Down Approach using a matrix table.               B1    B2    B3    B4    B5    B6    B7          A    B    C    C    B    U    A              A1    A    1    max((0),A1B1,A2B2)    max((0),A1B2,A2B3)    max((0),A1B6,A2B4)    max((0),A1B4,A2B5)    max((0),A1B5,A2B6)    max((A2B6==5?A2B6+2:0),A1B6,A2B7)          A2    B    0    1    max((0),A2B2,A3B3)    max((0),A2B3,A3B4)    max((A3B4==2?A3B4+2:0),A2B4,A3B5)    max((0),A2B5,A3B6)    max((0),A2B6,A3B7)          A3    C    0    0    1    max((A4B3==0?A4B3+2:0),A3B3,A4B4)    max((0),A3B4,A4B5)    max((0),A3B5,A4B6)    max((0),A3B6,A4B7)          A4    C    0    0    0    1    max((0),A4B4,A5B5)    max((0),A4B5,A5B6)    max((0),A4B6,A5B7)          A5    B    0    0    0    0    1    max((0),A5B5,A6B6)    max((0),A5B6,A6B7)          A6    U    0    0    0    0    0    1    max((0),A6B6,A7B7)          A7    A    0    0    0    0    0    0    1      To achieve bottom up approach, we then need to solve row by row starting from the last row. def lps(s: str) -&gt; int: dp = {} for col in range(len(s)):  for row in range(len(s)-1, -1, -1):   if row &gt; col:    dp[row, col] = 0   elif row == col:    dp[row, col] = 1   else:    if s[row] == s[col]:     length = 0     remainingLen = col - row - 1     if remainingLen == dp[row+1, col-1]:      length = 2     dp[row, col] = max(length+dp[row+1, col-1], dp[row, col-1], dp[row+1, col])    else:     dp[row, col] = max(dp[row, col-1], dp[row+1, col]) return dp[0, len(s)-1]"
    }, {
    "id": 13,
    "url": "/zero-one-knapsack/",
    "title": "0/1 Knapsack Problem",
    "body": "2020/05/11 - Given the weights and profits of N items, we are asked to put these items in a knapsack which as a capacity C. Restriction is, we cannot break the item into smaller units (fractional unit is not allowed). Find the maximum profit from the items in the knapsack. Example-----------items: [ Mango ,  Apple ,  Banana ,  Orange ]profits: [31, 26, 72, 17]weights: [3, 1, 5, 2]capacity: 7output: 98Explanation: Apple + Banana (total weight = 6) =&gt; 98 profitSolution: This problem can be solved by applying Divide and Conquer to break down the problem into smaller subproblems. Thus, by solving these subproblems, we will arrive at our final answer. Let’s try to derive the subproblems. 1. We take the first item: 31 + f([2,3,4], weight=3) --|-- max2. We skip the first item: 0 + f([2,3,4], weight=0)  --|To achieve optimal substructure, we assume that at every step, we would take the first item or we skip it. Hence, if we take the first time, we add on the profit and also run a recursive function and pass in the remaining items and the weight that this item takes and hence 31 + f([2,3,4], weight=3). If we skip the first item, we then run a recursive function, pass in the remaining items and since we skip the item, the weight is 0 and therefore 0 + f([2,3,4], weight=0). By getting the max value of these 2 subproblems, we would then derive at our final answer. Code Algortihm: def knapsack(profits: List[int], weights: List[int], capacity: int, index: int) -&gt; int:  if index &gt; len(profits)-1 or capacity == 0:   return 0  profit1: int = 0  if weights[index] &lt;= capacity:   profit1 = profits[index] + knapsack(profits, weights, capacity-weights[index], index+1)  profit2: int = knapsack(profits, weights, capacity, index+1)  return max(profit1, profit2)Optimisation: Let’s look at the an example of the recursion tree see if we need to optimise this solution.             knapsack(7, 0)         /            \      knapsack(4,1)        knapsack(7,1)      /     \        /       \  knapsack(3,1) knapsack(4,2)  knapsack(6,2)  knapsack(7,2)  /     \base    knapsack(3,3)Since there are no recurrences of any computation, we don’t have to but still can apply Dynamic Programming to optimise the solution. "
    }, {
    "id": 14,
    "url": "/number-factor/",
    "title": "Number Factor Problem",
    "body": "2020/05/11 - Given N, count the number of ways to express N as sum of 1,3 and 4. Example 1-----------n: 4num of ways: 4Explanation: There are four ways to express 'n': {4}, {1,3}, {3,1}, {1,1,1,1}Example 2-----------n: 5num of ways: 6Explanation: There are six ways to express 'n': {4,1}, {1,4}, {3,1,1}, {1,3,1}, {1,1,3}, {1,1,1,1,1}Solution: This problem can be solved by applying Divide and Conquer algorithm techniques. Firstly, let’s try to break the problem into smaller subproblems. Since we are given 3 numbers, {1,3,4}, let’s try to find the complements of those numbers and also the number of ways to form those complements. We will use the example where N = 5: n = 51 | + 4 = {1,1,1,1}, {1,3}, {3,1}, {4} = 4 ways3 | + 2 = {1,1} = 1 way4 | + 1 = {1} = 1 waynum of ways: 4 + 1 + 1 = 6By solving the subproblems, we arrive at the final result by getting the sum of all the answers to the subproblems. Code Algorithm: def num_ways(n: int) -&gt; int:  if n == 0 or n == 1 or n == 2:   return 1  if n == 3:   return 2  comp1: int = num_ways(n-1)  comp2: int = num_ways(n-3)  comp3: int = num_ways(n-4)  return comp1 + comp2 + comp3Optimisation: Let’s look at the an example of the recursion tree using N = 8 for a larger recursive tree and see if we can optimise this solution.          num_ways(8)   /        |          \num_ways(7)    num_ways(5)    num_ways(4) |          |          | |-num_ways(6)    |-num_ways(4)    |-num_ways(3) |-num_ways(4)    |-num_ways(2)    |-num_ways(1) |-num_ways(3)    |-num_ways(1)    |-num_ways(0)We are computing a new of the subproblems more than once such as num_ways(4). We can then apply Dynamic Programming to optimise the solution. Top Down Approach: We will start off by applying Top Down Approach (also known as Memoization). dp = {}def num_ways(n: int) -&gt; int: if n == 0 or n == 1 or n == 2:  return 1 if n == 3:  return 2 if n not in dp:  comp1: int = num_ways(n-1)  comp2: int = num_ways(n-3)  comp3: int = num_ways(n-4)  dp[n] = comp1 + comp2 + comp3 return dp[n]Bottom Up Approach: We can now then apply some reverse engineer to use the Bottom Up Approach (also known as Tabulation). Let’s visualise how dp is filled using Top Down Approach.           Iteration    Num of ways          DP0    DP1    DP2    DP3    DP4    DP5    DP6    DP7    DP8              1.     1    1    1    2    ?    ?    ?    ?    ?          2.     1    1    1    2    ?    ?    ?    ?    DP7+DP5+DP4          3.     1    1    1    2    ?    ?    ?    DP6+DP4+DP3    DP7+DP5+DP4          3.     1    1    1    2    ?    ?    DP5+DP3+DP2    DP6+DP4+DP3    DP7+DP5+DP4          4.     1    1    1    2    ?    DP4+DP2+DP1    DP5+DP3+DP2    DP6+DP4+DP3    DP7+DP5+DP4          5.     1    1    1    2    DP3+DP1+DP0    DP4+DP2+DP1    DP5+DP3+DP2    DP6+DP4+DP3    DP7+DP5+DP4          6.     1    1    1    2    2+1+1=4    DP4+DP2+DP1    DP5+DP3+DP2    DP6+DP4+DP3    DP7+DP5+DP4          7.     1    1    1    2    2+1+1=4    4+1+1=6    DP5+DP3+DP2    DP6+DP4+DP3    DP7+DP5+DP4          8.     1    1    1    2    2+1+1=4    4+1+1=6    6+2+1=9    DP6+DP4+DP3    DP7+DP5+DP4          9.     1    1    1    2    2+1+1=4    4+1+1=6    6+2+1=9    9+4+2=15    DP7+DP5+DP4          10.     1    1    1    2    2+1+1=4    4+1+1=6    6+2+1=9    9+4+2=15    15+6+4=25      We can then now reverse the process. Let’s visualize how Bottom Up Approach works here.           Iteration    Num of ways          DP0    DP1    DP2    DP3    DP4    DP5    DP6    DP7    DP8              1.     1    1    1    2    ?    ?    ?    ?    ?          1.     1    1    1    2    DP3+DP1+DP0    ?    ?    ?    ?          2.     1    1    1    2    2+1+1=4    ?    ?    ?    ?          3.     1    1    1    2    2+1+1=4    DP4+DP2+DP1    ?    ?    ?          4.     1    1    1    2    2+1+1=4    4+1+1=6    ?    ?    ?          5.     1    1    1    2    2+1+1=4    4+1+1=6    DP5+DP3+DP2    ?    ?          6.     1    1    1    2    2+1+1=4    4+1+1=6    6+2+1=9    ?    ?          7.     1    1    1    2    2+1+1=4    4+1+1=6    6+2+1=9    DP6+DP4+DP3    ?          8.     1    1    1    2    2+1+1=4    4+1+1=6    6+2+1=9    9+4+2=15    ?          9.     1    1    1    2    2+1+1=4    4+1+1=6    6+2+1=9    9+4+2=15    DP7+DP5+4          9.     1    1    1    2    2+1+1=4    4+1+1=6    6+2+1=9    9+4+2=15    15+6+4=25      def num_ways(n: int) -&gt; int: dp = {  0: 1,  1: 1,  2: 1,  3: 2 } for i in range(4, n+1):  dp[i] = dp[i-1] + dp[i-3] + dp[i-4] return dp[n]"
    }, {
    "id": 15,
    "url": "/longest-palindromic-subsequence/",
    "title": "Longest Palindromic Subsequence",
    "body": "2020/05/11 - Given a string S, we need to find the length of its Longest Palindromic Subsequence. Palindrome is a string that reads the same backwards as well as forward and can be odd or even length. A subsequence is a sequence that can be derived from another string by deleting some or no elements without changing the order of the remaining elements. Example 1-----------s:  ELRMENMET output: 5Explanation:  ELRMENMET  =&gt;  EMEME        ^ ^^ ^^Example 2-----------s:  AMEEWMEA output: 6Explanation:  AMEEWMEA  =&gt;  AMEEMA        ^^^^ ^ ^Solution: This problem can be solved by applying Divide and Conquer to break down the problem into smaller subproblems. Thus, by solving these subproblems, we will arrive at our final answer. Let’s try to derive the subproblems. If the first and last character matches: 2 + f(1,8)   ---|---maxIf it doesn't match: max of [0 + f(0,8)] or [0 + f(1,9)] ---|For palindrome, the first and last character should be the same so that it reads the same from the front and the back. Hence, to achive optimal substructure, if the first and last character matches, our answer increases by 2 and we move on to the next characters, hence, 2 + f(1,8). If it doesn’t match, we should then attempt to see if the next characters on both side matches and get the max value from it. Therefore, max of [0 + f(0,8)] or [0 + f(1,9)]. Code Algortihm: def lps(s: str, start: int, end: int) -&gt; int:  if start &gt; end:   return 0  if start == end:   return 1  count1 = 0  if s[start] == s[end]:   count1 = 2 + lps(s, start+1, end-1)  count2 = lps(s, start, end-1)  count3 = lps(s, start+1, end)  return max(count1, count2, count3)Optimisation: Let’s look at the an example of the recursion tree see if we need to optimise this solution.         lps(0,3)  /        |        \ lps(0,2)    lps(1,3)    lps(1,2) |        |        | |-lps(1,2)    |-lps(2,3)    |-lps(2,2) |-lps(0,1)    |-lps(1,2)    |-lps(1,1) |-lps(1,1)    |-lps(2,2)    |-lps(2,1)We are computing a new of the subproblems more than once such as lps(1,2). We can then apply Dynamic Programming to optimise the solution. Top Down Approach: We will start off by applying Top Down Approach (also known as Memoization). dp = {}def lps(s: str, start: int, end: int) -&gt; int:  if start &gt; end:   return 0  if start == end:   return 1  if (start, end) not in dp:   count1 = 0   if s[start] == s[end]:    count1 = 2 + lps(s, start+1, end-1)   count2 = lps(s, start, end-1)   count3 = lps(s, start+1, end)   dp[start, end] = max(count1, count2, count3)  return dp[start, end]Bottom Up Approach: We can now then apply some reverse engineer to use the Bottom Up Approach (also known as Tabulation). Firstly, let’s start from looking at the Top Down Approach using a matrix table.               B1    B2    B3    B4    B5    B6    B7    B8    B9          E    L    R    M    E    N    M    E    T              A1    E    1    max(0,A1B1,A2B2)    max(0,A1B2,A2B3)    max(0,A1B3,A2B4)    max(2+A2B4,A1B4,A2B5)    max(0,A1B5,A2B6)    max(0,A1B6,A2B7)    max(2+A2B7,A1B7,A2B8)    max(0,A1B8,A2B9)          A2    L    0    1    max(0,A2B2,A3B3)    max(0,A2B3,A3B4)    max(0,A2B4,A3B5)    max(0,A2B5,A3B6)    max(0,A2B6,A3B7)    max(0,A2B7,A3B8)    max(0,A2B8,A3B9)          A3    R    0    0    1    max(0,A3B3,A4B4)    max(0,A3B4,A4B5)    max(0,A3B5,A4B6)    max(0,A3B6,A4B7)    max(0,A3B7,A4B8)    max(0,A3B8,A4B9)          A4    M    0    0    0    1    max(0,A4B4,A5B5)    max(0,A4B5,A5B6)    max(2+A5B6,A4B6,A5B7)    max(0,A4B7,A5B8)    max(0,A4B8,A5B9)          A5    E    0    0    0    0    1    max(0,A5B5,A6B6)    max(0,A5B6,A6B7)    max(2+A6B7,A5B7,A6B8)    max(0,A5B8,A6B9)          A6    N    0    0    0    0    0    1    max(0,A6B6,A7B7)    max(0,A6B7,A7B8)    max(0,A6B8,A7B9)          A7    M    0    0    0    0    0    0    1    max(0,A7B7,A8B8)    max(0,A7B8,A8B9)          A8    E    0    0    0    0    0    0    0    1    max(0,A8B8,A9B9)          A9    T    0    0    0    0    0    0    0    0    1      We then need to find the cell which doesn’t have any dependency as our starting point as we will have our first answer there. That would be the last cell A9B9. And we slowly move our way up to the rest of the cells until we reach cell A1B9 which will give us our final answer. B8, A6 rows and columns are our base conditions where we return 0. def lps(s: str) -&gt; int: dp = {} for col in range(len(s)):  for row in range(len(s)-1, -1, -1):   if row &gt; col:    dp[row, col] = 0   elif row == col:    dp[row, col] = 1   else:    if s[row] == s[col]:     dp[row, col] = max(2+dp[row+1, col-1], dp[row, col-1], dp[row+1, col])    else:     dp[row, col] = max(dp[row, col-1], dp[row+1, col]) return dp[0, len(s)-1]"
    }, {
    "id": 16,
    "url": "/house-thief/",
    "title": "House Thief Problem",
    "body": "2020/05/11 - There are n houses built in a line, each containing some value. A thief is going to steal the maximum value from these houses. However, he can’t steal in 2 adjacent houses. What is the maximum stolen value? Example 1-----------n: [6, 7, 1, 30, 8, 2, 4]max value: 41Explanation: Thief will steal from houses with 7, 30, 4. Example 2-----------n: [20, 5, 1, 13, 6, 11, 40]max value: 73Explanation: Thief will steal from houses with 20, 13, 40. Solution: This problem can be solved by applying Divide and Conquer to break down the problem into smaller subproblems. Thus, by solving this subproblems, we will arrive at our final answer. Let’s look at Example 1 and try to derive the subproblems. f(7 houses) = max of [6 + f(remaining 5 houses)] or [0 + f(6 remaining 6 houses)]So, what the above subproblems are saying is that, since we can’t steal from two adjacent houses, the thief can either steal from the first house, and then skip the second house and move on to the other remaining 5 houses given that we have 7 houses in total. Hence 6 + f(remaining 5 houses). Or, the thief can skip the first house and steal from the remaining 6 houses, and hence, 0 + f(remaining 6 houses). We’re looking for the maximum value which the thief can steal. Therefore, we want to find the maximum value returned from the two subproblems. Code Algortihm: def steal_money(n: List[int], i: int) -&gt; int:  if i &gt;= len(n):   return 0  money1 = n[i] + steal_money(n, i+2)  money2 = steal_money(n, i+1)  return max(money1, money2)Optimisation: Let’s look at the an example of the recursion tree to examine whether we need to optimise it.                             steal_money(0)                           /         \                         /             \                       /                 \                     /                     \                   /                         \                steal_money(2)                    steal_money(1)            /              \                 /       \        steal_money(4)         steal_money(3)          steal_money(3)  steal_money(2)        /       \         /      \          /      \     steal_money(6) steal_money(5) steal_money(5) steal_money(4)  steal_money(5)  steal_money(4)    /       \steal_money(8)  steal_money(7)We can see from the above recursion tree that steal_money(3), steal_money(4) and steal_money(5) have been computed multiple times. Hence, we can apply Dynamic Programming to optimise this solution. Top Down Approach: We will start off by applying Top Down Approach (also known as Memoization). dp = {}def steal_money(n: List[int], i: int) -&gt; int:  if i &gt;= len(n):   return 0  if i not in dp:   money1 = n[i] + steal_money(n, i+2)   money2 = steal_money(n, i+1)   dp[i] = max(money1, money2)  return dp[i]Bottom Up Approach: We can now then apply some reverse engineer to use the Bottom Up Approach (also known as Tabulation). Let’s visualise how dp is filled using Top Down Approach.           Iteration    Steal Money          DP0    DP1    DP2    DP3    DP4    DP5    DP6              1.     ?    ?    ?    ?    ?    ?    ?          2.     max(H0+DP[2],DP[1])    ?    ?    ?    ?    ?    ?          3.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    ?    ?    ?    ?    ?          4.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    ?    ?    ?    ?          5.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    max(H3+DP[5],DP[4])    ?    ?    ?          6.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    max(H3+DP[5],DP[4])    max(H4+DP[6],DP[5])    ?    ?          7.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    max(H3+DP[5],DP[4])    max(H4+DP[6],DP[5])    max(H5+DP[7],DP[6])    ?          8.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    max(H3+DP[5],DP[4])    max(H4+DP[6],DP[5])    max(H5+DP[7],DP[6])    max(H6+DP[8],DP[7])           9.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    max(H3+DP[5],DP[4])    max(H4+DP[6],DP[5])    max(H5+DP[7],DP[6])    max(4+0,0)=4          10.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    max(H3+DP[5],DP[4])    max(H4+DP[6],DP[5])    max(2+0,4)=4    max(4+0,0)=4          11.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    max(H3+DP[5],DP[4])    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4          12.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(H2+DP[4],DP[3])    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4          13.     max(H0+DP[2],DP[1])    max(H1+DP[3],DP[2])    max(1+12,34)=34    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4          14.     max(H0+DP[2],DP[1])    max(7+34,34)=41    max(1+12,34)=34    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4          15.     max(6+34,41)=41    max(7+34,34)=41    max(1+12,34)=34    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4      We can then now reverse the process. Let’s visualize how Bottom Up Approach works here.           Iteration    Steal Money          DP0    DP1    DP2    DP3    DP4    DP5    DP6    DP7    DP8              1.     ?    ?    ?    ?    ?    ?    ?    0    0          2.     ?    ?    ?    ?    ?    ?    max(H6+DP[8],DP[7])    0    0          2.     ?    ?    ?    ?    ?    ?    max(4+0,0)=4    0    0          3.     ?    ?    ?    ?    ?    max(H5+DP[7],DP[6])    max(4+0,0)=4    0    0          3.     ?    ?    ?    ?    ?    max(2+0,4)=4    max(4+0,0)=4    0    0          4.     ?    ?    ?    ?    max(H4+DP[6],DP[5])    max(2+0,4)=4    max(4+0,0)=4    0    0          5.     ?    ?    ?    ?    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4    0    0          6.     ?    ?    ?    max(H3+DP[5],DP[4])    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4    0    0          7.     ?    ?    ?    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4    0    0          8.     ?    ?    max(H2+DP[4],DP[3])    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4    0    0          9.     ?    ?    max(1+12,34)=34    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4    0    0          10.     ?    max(H1+DP[3],DP[2])    max(1+12,34)=34    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4    0    0          11.     ?    max(7+34,34)=41    max(1+12,34)=34    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4    0    0          12.     max(6+34,41)=41    max(7+34,34)=41    max(1+12,34)=34    max(30+4,12)=34    max(8+4,4)=12    max(2+0,4)=4    max(4+0,0)=4    0    0      def steal_money(n: List[int]) -&gt; int: dp = {} for i in range(len(n)+1, -1, -1):  if i &gt; len(n) - 1:   dp[i] = 0  else:   dp[i] = max(n[i] + dp[i+2], dp[i+1]) return dp[0]"
    }, {
    "id": 17,
    "url": "/convert-one-string-to-another/",
    "title": "Convert One String to Another Problem",
    "body": "2020/05/11 - Given strings s1 and s2, convert s2 into s1 by deleting, inserting or replacing characters. Find out the minimum number of edit operations. Example 1-----------s1:  catch s2:  carch output: 1Explanation: Replace 'r' with 't'. Example 2-----------s1:  table s2:  tbres Explanation: Insert 'a' at second position, replace 'r' with 'l' and delete 's'. Solution: This problem can be solved by applying Divide and Conquer to break down the problem into smaller subproblems. Thus, by solving these subproblems, we will arrive at our final answer. Let’s look at Example 2 and try to derive the subproblems. Delete---------s1 =  table  --|-- f(2,3) ---|--- mins2 =  tgable  --|       |               |Insert            |---------           |s1 =  table  --|-- f(3,2)  --|s2 =  tble  --|       |               |Replace            |---------           |s1 =  table  --|-- f(3,3)  --|s2 =  tcble  --|       |So, what the derived above subproblems, we know that there will be 3 operations, Insert, Replace and Delete. Hence, we explore how each operations will then move on to the next subproblem. If it is a delete operation, we will stay on the same index for s1 and increment the index for s2 and hence, f(2,3). For an insert operation, we should increment the index for s1 and stay on the same index for s2 since logically the length of s2 will increase by 1 and hence, f(3,2). For replace operation, we should increment both the indexes for s1 and s2 since we then assume the current character is now identical after the replacement. Lastly, getting the minimum of the 3 subproblems will get us to the final answer. Code Algortihm: def min_ops(s1: str, s2: str, i1: int, i2: int) -&gt; int:  if i1 == len(s1):   return len(s2)-i2  if i2 == len(s2):   return len(s1)-i1  if s1[i1] == s2[i2]:   return min_ops(s1, s2, i1+1, i2+1)  insert = 1 + min_ops(s1, s2, i1+1, i2)  replace = 1 + min_ops(s1, s2, i1+1, i2+1)  delete = 1 + min_ops(s1, s2, i1, i2+1)  return min(insert, replace, delete)Optimisation: Let’s look at the an example of the recursion tree see if we need to optimise this solution.          min_ops(0,0)   /        |          \min_ops(1,0)    min_ops(0,1)    min_ops(1,1) |          |          | |-min_ops(2,0)   |-min_ops(1,1)   |-min_ops(2,1) |-min_ops(1,1)   |-min_ops(0,2)   |-min_ops(1,2) |-min_ops(2,1)   |-min_ops(1,2)   |-min_ops(2,2)We are computing a new of the subproblems more than once such as min_ops(1,1) and min_ops(2,1). We can then apply Dynamic Programming to optimise the solution. Top Down Approach: We will start off by applying Top Down Approach (also known as Memoization). dp = {}def min_ops(s1: str, s2: str, i1: int, i2: int) -&gt; int:  if (i1, i2) not in dp:   if i1 == len(s1):    dp[i1, i2] = len(s2)-i2   elif i2 == len(s2):    dp[i1, i2] = len(s1)-i1   elif s1[i1] == s2[i2]:    dp[i1, i2] = min_ops(s1, s2, i1+1, i2+1)   else:    insert = 1 + min_ops(s1, s2, i1+1, i2)    replace = 1 + min_ops(s1, s2, i1+1, i2+1)    delete = 1 + min_ops(s1, s2, i1, i2+1)    dp[i1, i2] = min(insert, replace, delete)  return dp[i1, i2]Bottom Up Approach: We can now then apply some reverse engineer to use the Bottom Up Approach (also known as Tabulation). Let’s visualise how dp is filled using Top Down Approach.               B1    B2    B3    B4    B5    B6          T    A    B    L    E                  A1    T    A2B2    ?    ?    ?    ?              A2    B    ?    1+min(A3B2,A2B3,A3B3)    A3B4    ?    ?              A3    R    ?    1+min(A4B2,A3B3,A4B3)    1+min(A5B4,A4B5,A5B5)    1+min(A4B4,A3B5,A4B5)    1+Min(A4B5,A3B6,A4B6)    3          A4    E    ?    1+min(A5B2,A5B3,A5B3)    1+min(A5B3,A4B4,A5B4)    1+min(A5B4,A4B5,A5B5)    A5B6    2          A5    S    ?    1+min(A6B2,A6B3,A6B3)    1+min(A6B3,A5B4,A6B4)    1+min(A6B4,A5B5,A6B5)    1+min(A6B5,A5B6,A6B6)    1          A6            4    3    2    1    0      We then need to find where the first solution of the subproblem starts. And this is actually the A6B2 cell. And then the base solutions start to move to all the A6 and B6 cells. Finally, it slowlys move towards the subproblems that doesn’t have an answer and then to cell A1B1 where we will arrive at our final answer. def min_ops(s1: str, s2: str) -&gt; int: dp = {} for i1 in range(len(s1)-1):  dp[i1, 0] = i1 for i2 in range(len(s2)-1):  dp[0, i2] = i2 for i1 in range(1, len(s1)):  for i2 in range(1, len(s2)):   if s1[i1] == s2[i2]:    dp[i1, i2] = dp[i1-1, i2-1]   else:    dp[i1, i2] = 1 + min(dp[i1-1, i2], min(dp[i1, i2-1], dp[i1-1, i2-1])) return dp[len(s1)-1, len(s2)-1]"
    }, {
    "id": 18,
    "url": "/quick-sort/",
    "title": "Quick Sort",
    "body": "2020/05/08 - Quick sort is a Divide &amp; Conquer algorithm. At each step, it finds the Pivot and then makes sure that all the smaller elements are left of Pivot and all larger elements are on the right. It continues to do so recursively until the entire array is sorted. Unlike Merge Sort, it doesn’t requires any external space. Code algorithm: Let’s now look at how to implement it in code. def quickSort(arr: List[int], start: int, end: int) -&gt; None: if start &lt; end:  pivot: int = partition(arr, start, end)  quickSort(arr, start, pivot - 1)  quickSort(arr, pivot + 1, end)def partition(arr: List[int], p: int, q: int) -&gt; int: pivot: int = q i: int = p - 1 for j in range(p, q+1):  if arr[j] &lt;= arr[pivot]:   i += 1   temp: int = arr[i]   arr[i] = arr[j]   arr[j] = temp return iFor time and space complexity, check out my post on Run Time Complexity. "
    }, {
    "id": 19,
    "url": "/merge-sort/",
    "title": "Merge Sort",
    "body": "2020/05/06 - Merge sort is a Divide &amp; Conquer algorithm. It divides the input array into 2 halves, and recursively breaks those halves until they become so small that it can’t be broken further. Then, each section of the pieces are merged together to inch towards the final answer.           [30, 20, 40, 10, 80, 50, 15]         /               \    [30, 20, 40, 10]           [80, 50, 15]    /       \            /     \ [30, 20]     [40, 10]        [80,50]    [15] /   \     /   \        /   \     \[30]  [20]   [40]  [10]      [80]  [50]    [15] \   /     \   /        \   /     / [20, 30]     [10, 40]        [50,80]    [15]    \      /             \     /    [10, 20, 30, 40]            [15, 50, 80]           \             /           [10, 15, 20, 30, 40, 50, 60]Code algorithm: Let’s now look at how to implement it in code. import sysdef mergeSort(a: List[int], left: int, right: int) -&gt; None: if right &gt; left:  mid = (left + right) / 2  mergeSort(a, left, mid)  mergeSort(a, mid + 1, right)  merge(a, left, mid, right)def merge(a: List[int], left: int, mid: int, right: int) -&gt; None: leftTmp: List[int] = [None for _ in range(mid - left + 2)] rightTmp: List[int] = [None for _ in range(right - mid + 1)] for i in range(mid - left + 1):  leftTmp[i] = a[left + i] for i in range(right - mid):  rightTmp[i] = a[mid + 1 + i] leftTmp[mid - left + 1] = sys. maxsize rightTmp[right - mid] = sys. maxsize i: int = 0 j: int = 0 for k in range(left, right + 1):  if leftTmp[i] &lt; rightTmp[j]:   a[k] = leftTmp[i]   i += 1  else:   a[k] = rightTmp[j]   j += 1For time and space complexity, check out my post on Run Time Complexity. "
    }, {
    "id": 20,
    "url": "/simple-linear-regression/",
    "title": "Simple Linear Regression",
    "body": "2020/05/05 - Let’s explore how we can implement Simple Linear Regression in this post. Firstly let’s take a look at the dataset used. Data. csv YearsExperience,Salary1. 1,39343. 001. 3,46205. 001. 5,37731. 002. 0,43525. 002. 2,39891. 002. 9,56642. 003. 0,60150. 003. 2,54445. 003. 2,64445. 003. 7,57189. 003. 9,63218. 004. 0,55794. 004. 0,56957. 004. 1,57081. 004. 5,61111. 004. 9,67938. 005. 1,66029. 005. 3,83088. 005. 9,81363. 006. 0,93940. 006. 8,91738. 007. 1,98273. 007. 9,101302. 008. 2,113812. 008. 7,109431. 009. 0,105582. 009. 5,116969. 009. 6,112635. 0010. 3,122391. 0010. 5,121872. 00Math expression:  y = b0 + b1*x1 y = dependent variable (DV) -The column that is being predicted.  b0 = constant - Point where the line crosses the vertical axis.  b1 = coefficient - Slope of the line.  x1 = independent variable (IV) - Also known as the features; are the columns which are being used to predict the dependent variable. Salary is the column that we want to predict, and hence it is the dependent variable. YearsExperience is the column used to predict the dependent variable and hence it is the independent variable. Hence, the formula will translate to Salary = b0 + b1*YearsExperience. Chart drawing example: Code example: Firstly, we need to import the dataset. Check out my post on Data preprocessing to get the step by step guide on how to do so.  Why didn’t we apply Feature Scaling in our Simple Linear Regression model?  It’s simply because since y is a linear combination of the independent variables, the coefficients can adapt their scale to put everything on the same scale. For example if you have two independent variables x1 and x2 and if y takes values between 0 and 1, x1 takes values between 1 and 10 and x2 takes values between 10 and 100, then b1 can be multiplied by 0. 1 and b2 can be multiplied by 0. 01 so that y, b1x1 and b2x2 are all on the same scale. Training the Simple Linear Regression model on the training set: scikit-learn to the rescue. They made it super simple to train model. Just 3 lines of code. from sklearn. linear_model import LinearRegressionregressor = LinearRegression()regressor. fit(x_train, y_train) What does ’regressor. fit(X_train, y_train)’ do exactly?  The fit method will take the values of X_train and y_train and then will compute the coefficients b0 and b1 of the Simple Linear Regression equation (y = b0 + b1x). That’s the whole purpose of this fit method here.  To learn more about scikit-learn’s LinearRegression class, check out their docs. Predicting the Test set results: y_pred = regressor. predict(x_test)print(y_pred)# [ 40748. 96184072 122699. 62295594 64961. 65717022 63099. 14214487# 115249. 56285456 107799. 50275317]Visualising the Training set results: matplotlib makes it super easy to visualise in a chart. We’re using the scatter method here to view the results in a scatter chart. plt. scatter(x_train, y_train, color='red')plt. plot(x_train, regressor. predict(x_train), color='blue')plt. title('Salary vs Experience (Training set)')plt. xlabel('Years of Experience')plt. ylabel('Salary')plt. show() To learn more about matplotlib scatter method, check out their docs Visualising the Test set results: I need to point out that we’re using back our x_train instead of x_test in the predict method for the regressor. This is because, we are testing it against the training model and not the test model. plt. scatter(x_test, y_test, color='red')plt. plot(x_train, regressor. predict(x_train), color='blue')plt. title('Salary vs Experience (Test set)')plt. xlabel('Years of Experience')plt. ylabel('Salary')plt. show() "
    }, {
    "id": 21,
    "url": "/depth-first-search/",
    "title": "Depth First Search",
    "body": "2020/05/04 - DFS is an algorithm for traversing Graph data structures. It starts by selecting some arbitrary node and explores as far as possible along each edge before backtracking. In the easiest possible way to explain: Code algorithm: For DFS, we utilise stack to help with the operations. def dfs(graph): stack = [] for node in graph:  if not node. isVisited:   continue  stack. append(node)  while not len(stack) &gt; 0:   current_node = stack. pop()   if current_node. isVisited: continue   current_node. isVisited = True   print(current_node. value)   for neighbour in current_node. neighbours:    if neighbour. isVisited: continue    stack. append(neighbour)For time and space complexity, check out my post on Run Time Complexity. "
    }, {
    "id": 22,
    "url": "/data-preprocessing/",
    "title": "Data Preprocessing, the basics to Machine Learning",
    "body": "2020/05/03 - To start with machine learning, learning how to handle data is key, since machine learning is driven by data. Importing the libraries: import numpy as npimport matplotlib. pyplot as pltimport pandas as pd Find out more about numpy, matplotlib and pandas Importing the dataset: Data. csv Country,Age,Salary,PurchasedFrance,44,72000,NoSpain,27,48000,YesGermany,30,54000,NoSpain,38,61000,NoGermany,40,,YesFrance,35,58000,YesSpain,,52000,NoFrance,48,79000,YesGermany,50,83000,NoFrance,37,67000,YesSo we’re going to separate the dataset into matrix of features and dependent variable vectors.  Matrix of features: These are the columns which are being used to predict the dependent variable.  Dependent variable vectors: The column that that is being predicted. dataset = pd. read_csv('Data. csv')x = dataset. iloc(:, :-1). valuesy = dataset. iloc(:, -1). values What does ’iloc’ exactly do?  It locates the column by its index. In other words, using ’iloc’ allows us to take columns by just taking their index.  Why do we create x and y separately?  Because we want to work with Numpy arrays, instead of Pandas dataframes. Numpy arrays are the most convenient format to work with when doing data preprocessing and building Machine Learning models. So we create two separate arrays, one that contains our independent variables (also called the input features), and another one that contains our dependent variable (what we want to predict). x refers to the matrix of features which are actually the first 3 columns, Conutry, Age and Salary. And y is the dependent variable vector which will be predicted and is the last column Purchased. Hence, to further explain the code above, I’m using the pandas library to import Data. csv file and then using the iloc method which is available from the library to define the columns which are needed for x and y separately.  To understand more about how the semicolon (:) works in python, check out this Stackoverflow explanation. print(x)# [['France' 44. 0 72000. 0]# ['Spain' 27. 0 48000. 0]# ['Germany' 30. 0 54000. 0]# ['Spain' 38. 0 61000. 0]# ['Germany' 40. 0 nan]# ['France' 35. 0 58000. 0]# ['Spain' nan 52000. 0]# ['France' 48. 0 79000. 0]# ['Germany' 50. 0 83000. 0]# ['France' 37. 0 67000. 0]]print(y)# ['No' 'Yes' 'No' 'No' 'Yes' 'Yes' 'No' 'Yes' 'No' 'Yes']Taking care of missing data: There are 3 ways to handle missing data in any cell:  Replace by average (mean).  Replace by median.  Replace by most frequent value.  Replacing missing values by average (mean) is the most classic and recommended way. from sklearn. impute import SimpleImputerimputer = SimpleImputer(missing_values=np. nan, strategy='mean')imputer. fit(x[:, 1:3])x[:, 1:3] = imputer. transform(x[:, 1:3])To handle missing data, we make use of the scikit-learn library.  What is the difference between fit and transform?  The fit part is used to extract some info of the data on which the object is applied (here, Imputer will spot the missing values and get the mean of the column). Then, the transform part is used to apply some transformation (here, Imputer will replace the missing value by the mean). print(x)# [['France' 44. 0 72000. 0]# ['Spain' 27. 0 48000. 0]# ['Germany' 30. 0 54000. 0]# ['Spain' 38. 0 61000. 0]# ['Germany' 40. 0 63777. 77777777778]# ['France' 35. 0 58000. 0]# ['Spain' 38. 77777777777778 52000. 0]# ['France' 48. 0 79000. 0]# ['Germany' 50. 0 83000. 0]# ['France' 37. 0 67000. 0]]Encoding categorical data: Encoding is a technique to convert string values into numerical values. Why is encoding needed? Since there are string values in the dataset, it will be difficult for machine learning model to compute some correlations between these columns. Encoding the Independent Variable: One idea would be to encode France into 0, Spain into 1 and Germany into 2. However the machine learning model would understand that because France is 0, Spain is 1 and Germany is 2, there is a numerical order between these countries. That is absolutely not the case. There is not a relationship order between these countries. We want to avoid to have such an interpretation for the model because that would cause some misinterpreted correlations between features and the prediction outcome. Hence a better technique would be One hot encoding. For example, the country column would be turned into 3 columns because there are actually 3 different classes in the country column. So if there are 5 different countries in the country column, it would then be turned into 5 columns. One hot encoding consists of creating binary vectors for each of the countries. Hence, France would have the vector 1 0 0, Spain would be 0 1 0, and Germarny 0 0 1. There would then be no numerical order between these countries.  One hot encoding is extremely useful and popular method to use when the data sets contain categorical variables. from sklearn. compose import ColumnTransformerfrom sklearn. preprocessing import OneHotEncoderct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), [0])], remainder='passthrough')x = np. array(ct. fit_transform(x))print(x)# [[1. 0 0. 0 0. 0 44. 0 72000. 0]# [0. 0 0. 0 1. 0 27. 0 48000. 0]# [0. 0 1. 0 0. 0 30. 0 54000. 0]# [0. 0 0. 0 1. 0 38. 0 61000. 0]# [0. 0 1. 0 0. 0 40. 0 63777. 77777777778]# [1. 0 0. 0 0. 0 35. 0 58000. 0]# [0. 0 0. 0 1. 0 38. 77777777777778 52000. 0]# [1. 0 0. 0 0. 0 48. 0 79000. 0]# [0. 0 1. 0 0. 0 50. 0 83000. 0]# [1. 0 0. 0 0. 0 37. 0 67000. 0]] What do the two ’fit_transform’ methods do?  When the ’fit_transform()’ method is called from the LabelEncoder() class, it transforms the categories strings into integers. For example, it transforms France, Spain and Germany into 0, 1 and 2. Then, when the ’fit_transform()’ method is called from the OneHotEncoder() class, it creates separate columns for each different labels with binary values 0 and 1. Those separate columns are the dummy variables. Encoding the Dependent Variable: from sklearn. preprocessing import LabelEncoderle = LabelEncoder()y = le. fit_transform(y)print(y)# [0 1 0 0 1 1 0 1 0 1]Splitting the dataset into the Training set and Test set:  Training set. Used to train the model.  Test Set. Used to test the model performance. The recommended ratio is 80% of the dataset to be used for training and 20% and test.  Why dataset spliting comes first and feature scale later?  Feature scaling is a technique to get the mean and standard deviation of the feature, so if we apply feature scaling before splitting, then it will actually get the mean and standard deviation of all the values including the ones in the test set and since the test set is not something we’re supposed to have for data in production, it would then caused information leakage on the test set. Hence, tt is to prevent information leakage on the test set which we’re not supposed to have until the training is done.  Why do we split on the dependent variable?  Because we want to have well distributed values of the dependent variable in the training and test set. For example if we only had the same value of the dependent variable in the training set, our model wouldn’t be able to learn any correlation between the independent and dependent variables. from sklearn. model_selection import train_test_splitx_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0. 2, random_state=1)print(x_train)# [[0. 0 0. 0 1. 0 38. 77777777777778 52000. 0]# [0. 0 1. 0 0. 0 40. 0 63777. 77777777778]# [1. 0 0. 0 0. 0 44. 0 72000. 0]# [0. 0 0. 0 1. 0 38. 0 61000. 0]# [0. 0 0. 0 1. 0 27. 0 48000. 0]# [1. 0 0. 0 0. 0 48. 0 79000. 0]# [0. 0 1. 0 0. 0 50. 0 83000. 0]# [1. 0 0. 0 0. 0 35. 0 58000. 0]]print(x_test)# [[0. 0 1. 0 0. 0 30. 0 54000. 0]# [1. 0 0. 0 0. 0 37. 0 67000. 0]]print(y_train)# [0 1 0 0 1 1 0 1]print(y_test)# [0 1]Feature Scaling: There are 2 ways to scale the features. And the most recommended way is Standardisation. Standardisation = x - mean(+x) / standard deviation(x)Normalisation = x - min(x) / max(x) = min(x) Standardisation will always work all the time (-3:+3, -2:+2 etc) Normalisation is recommend when you have a normal distribution in most of the features (0:1) Do we have to apply feature scaling to the dummy variables in the matrix of features  No. The goal of standardisation or feature scaling in general is to have all the values of the features in the same range. Hence, if we apply standardisation to the dummy variables, we will get nonsense numerical values which will make it incapable to tell which couple of three values here correspond to the which country. And also the dummy variables are already in the same range as the scaling. Hence, only apply feature scaling to the numerical values. from sklearn. preprocessing import StandardScalersc = StandardScaler()x_train[:, 3:] = sc. fit_transform(x_train[:, 3:])# Use the same scale as x_train and just transform the test to apply the forumlax_test[:, 3:] = sc. transform(x_test[:, 3:])print(x_train)# [[0. 0 0. 0 1. 0 -0. 19159184384578545 -1. 0781259408412425]# [0. 0 1. 0 0. 0 -0. 014117293757057777 -0. 07013167641635372]# [1. 0 0. 0 0. 0 0. 566708506533324 0. 633562432710455]# [0. 0 0. 0 1. 0 -0. 30453019390224867 -0. 30786617274297867]# [0. 0 0. 0 1. 0 -1. 9018011447007988 -1. 420463615551582]# [1. 0 0. 0 0. 0 1. 1475343068237058 1. 232653363453549]# [0. 0 1. 0 0. 0 1. 4379472069688968 1. 5749910381638885]# [1. 0 0. 0 0. 0 -0. 7401495441200351 -0. 5646194287757332]]print(x_test)# [[0. 0 1. 0 0. 0 -1. 4661817944830124 -0. 9069571034860727]# [1. 0 0. 0 0. 0 -0. 44973664397484414 0. 2056403393225306]]"
    }, {
    "id": 23,
    "url": "/longest-common-subsequence/",
    "title": "Longest Common Subsequence",
    "body": "2020/04/30 - Divide &amp; Conquer algorithm can be used to solve Longest Common Subsequence problem . Let’s explore how it works below. Problem Statement:  We are given two strings s1 and s2.  We need to find the length of the longest subsequence which is common in both the strings.  Subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Example 1: Input:  elephant ,  erepat Output: 5Explanation: The longest substring is  eepat . Example 2: Input:  houdini ,  hdupti Output: 3Explanation: The longest substring is  hui . Solution: Using Example 1 as a reference, we need to determine the probablity. Typically when comparing 2 characters, there are 2 probablities: Matches: Say, if we check the first characters of each string. Since they matches, we can say that 1 + F(2, 2). Let’s go in depth on the subproblem above. There is an additional of 1 because we have a match on the first character. The second part F(2, 2) means that for the next iteration where we’re moving to the second character for each string. Doesn’t match: Since it doesn’t match, we can say that 0 + F(3, 2), and also 0 + F(2, 3). As the characters doesn’t match, we need to stay at the same character for one of the string and move to the next character for the other. Getting the answer: Hence, if we manage to solve the subproblems, the end result would be the maximum value of these 3 subproblems. Code algorithm: def lcs(s1, s2, i1, i2): if i1 == len(s1) or i2 == len(s2):  return 0 c3 = 0 if s1[i1] == s2[i2]:  c3 = 1 + find_lcs_length(s1, s2, i1+1, i2+1) c1 = find_lcs_length(s1, s2, i1, i2+1) c2 = find_lcs_length(s1, s2, i1+1, i2) return max(c1, c2, c3)Optimisation: So the solution is not optimised. Why would I say that? This is because, we are running certain calculation twice or more. Let’s take a look at the recursion tree below:        lcs(0,0)  /       |       \lcs(0,1)    lcs(1,0)    lcs(1,1) |        |        | |-lcs(0,2)   |-lcs(1,1)   |-lcs(1,2) |-lcs(1,1)   |-lcs(2,0)   |-lcs(2,1) |-lcs(1,2)   |-lcs(2,1)   |-lcs(2,2)We are actually running lcs(1,1) at least 3 times, lcs(1,2) at least twice, etc. This is a case of overlapping subproblems. Hence in order to optimise this solution we can use Dynamic Programming. Top Down Approach: Top Down Approach is also known as Memoization. Below shows the code algorithm to achieve this approach. dp = {}def lcs(s1, s2, i1, i2): if i1 == len(s1) or i2 == len(s2):  return 0 if (i1, i2) not in dp[i1, i2]: # We'll only solve this problem if we haven't already done it  c3 = 0  if s1[i1] == s2[i2]:   c3 = 1 + find_lcs_length(s1, s2, i1+1, i2+1)  c1 = find_lcs_length(s1, s2, i1, i2+1)  c2 = find_lcs_length(s1, s2, i1+1, i2)  dp[i1, i2] = max(c1, c2, c3) return dp[i1, i2]As we can see above, it is almost the same as Divide &amp; Conquer except for the additonal variable to store already-solved subproblems. This would ensure that we don’t run the recursion again to solve something that was already solved. Bottom Up Approach: Bottom Up Approach is also known as Tabulation. This approach is more complex as compared to Top Down Approach. Hence, let’s explore the solution. Firstly, let’s start from looking at the Top Down Approach using a matrix table with Example 2 as the test input.               B1    B2    B3    B4    B5    B6    B7    B8          H    O    U    D    I    N    I                  A1    H    max(1+A2B2, A1B2, A2B1)    max(A1B3, A2B2)    max(A1B4, A2B3)    max(A1B5, A2B4)    max(A1B6, A2B5)    max(A1B7, A2B6)    max(A1B8, A2B7)    0          A2    U    max(A2B2, A3B1)    max(A2B3, A3B2)    max(1+A3K4, A2B4, A3B3)    max(A2B5, A3B4)    max(A2B6, A3B5)    max(A2B7, A3B6)    max(A2B8, A3B7)    0          A3    I    max(A3B2, A4B1)    max(A3B3, A4B2)    max(A3B4, A4B3)    max(A3B5, A4B4)    max(1+A4B6, A3B6, A4B5)    max(A3B7, A4B6)    max(A3B8, A4B7)    0          A4    N    max(A4B2, A5B1)    max(A4B3, A5B2)    max(A4B4, A5B3)    max(A4B5, A5B4)    max(A4B6, A5B5)    max(1+A5B7, A4B7, A5B6)    max(A4B8, A5B7)    0          A5    D    max(A5B2, A6B1)    max(A5B3, A6B2)    max(A5B4, A6B3)    max(1+A6B5, A5B5, A6B4)    max(A5B6, A6B5)    max(A5B7, A6B6)    max(A5B8, A6B7)    0          A6        0    0    0    0    0    0    0    0      We then need to find the cell which doesn’t have any dependency as our starting point as we will have our first answer there. That would be the last cell A5B7. And we slowly move our way up to the rest of the cells until we reach the first cell A1B1 which will give us our final answer. B8, A6 rows and columns are our base conditions where we return 0. def lcs(s1, s2): dp = {} for i in range(len(s1), 0, -1):  for j in range(len(s2), 0, -1):   if s1[i-1] == s2[j-1]:    dp[i,j] = max(1 + dp[i-1, j-1], dp[i, j+1], dp[i+1, j])   else:    do[i,j] = max(dp[i,j+1], dp[i+1,j]) return dp[0][0]"
    }, {
    "id": 24,
    "url": "/breadth-first-search/",
    "title": "Breadth First Search",
    "body": "2020/04/29 - BFS is an algorithm for traversing Graph data structures. It starts at some arbitrary node of a graph and explores the neighbour nodes (which are at current level) first, before moving to the next level neighbours. In the easiest possible way to explain: Code algorithm: For BFS, we utilise queue to help with the operations. def bfs(graph): queue = Queue() for node in graph:  if not node. isVisited:   continue  queue. enqueue(node)  while not queue. is_empty():   current_node = queue. dequeue()   if current_node. isVisited: continue   current_node. isVisited = True   print(current_node. value)   for neighbour in current_node. neighbours:    if neighbour. isVisited: continue    queue. enqueue(neighbour)For time and space complexity, check out my post on Run Time Complexity. "
    }, {
    "id": 25,
    "url": "/run-time-complexity/",
    "title": "A cheat guide to run time complexity",
    "body": "2020/04/28 - This guide is curated to help prepare for technical interviews. I’ve complied all the useful information including how to calculate the complexity in this guide. Table of contents:  Big-O Complexity Chart Common Data Structure Operations     Physical Data Structures         Array     Linked List          Logical Data Structures         Stack     Queue     Tree             Binary Tree       Binary Search Tree &amp; AVL Tree                Heap (Using Array)     Hash Table     Graphs             Common Operations       Common Algorithms for Graph problems                      Sorting Algorithms How to find time complexity     Iterative   Recursive #1   Recursive #2   Big-O Complexity Chart:  Disclaimer: I didn’t create this chart, it’s adapted from https://www. bigocheatsheet. com/. All credits goes to Eric.           Types    Name    Example              O(1)    Constant    Adding an element at front of linked list          O(log n)    Logarithmic    Finding an element in sorted array          O(n)    Linear    Finding an element in unsorted array          O(n log n)    Linear Logarithmic    Merge Sort          O(n2)    Quadratic    Shortest path between 2 nodes in a graph          O(n3)    Cubic    Matrix Multiplication          O(2n)    Exponential    Tower of Hanoi Problem      Common Data Structure Operations: Below are some common data structure and their operation time and space complexity. Physical Data Structures: There are two types of physical data structures, array and linked list. Array:           Operations    1D Array    2D Array          Time Complexity    Space Complexity    Time Complexity    Space Complexity              create()    O(1)    O(n)    O(1)    O(mn)          insert()    O(1)    O(1)    O(1)    O(1)          traverse()    O(n)    O(1)    O(mn)    O(1)          access[n]    O(1)    O(1)    O(1)    O(1)          search()    O(n)    O(1)    O(mn)    O(1)          delete()    O(1)    O(1)    O(1)    O(1)      Linked List:           Operations    Single Linked List    Double Linked List          Time Complexity    Space Complexity    Time Complexity    Space Complexity              create()    O(1)    O(1)    O(1)    O(1)          insert()    O(n)    O(1)    O(n)    O(n)          traverse()    O(n)    O(1)    O(n)    O(1)          search()    O(n)    O(1)    O(n)    O(1)          deleteNode()    O(n)    O(1)    O(n)    O(1)          deleteList()    O(1)    O(1)    O(n)    O(1)      Logical Data Structures: Below are some common types of logical data structures. Stack:           Operations    using Array    using Linked List          Time Complexity    Space Complexity    Time Complexity    Space Complexity              createStack()    O(1)    O(n)    O(1)    O(1)          push()    O(1)    O(1)    O(1)    O(1)          pop()    O(1)    O(1)    O(1)    O(1)          peek()    O(1)    O(1)    O(1)    O(1)          isEmpty()    O(1)    O(1)    O(1)    O(1)          isFull()    O(1)    O(1)    N/A    N/A          deleteStack()    O(1)    O(1)    O(1)    O(1)      Queue:           Operations    using Array    using Linked List          Time Complexity    Space Complexity    Time Complexity    Space Complexity              createQueue()    O(1)    O(n)    O(1)    O(1)          enqueue()    O(1)    O(1)    O(1)    O(1)          dequeue()    O(1)    O(1)    O(1)    O(1)          peek()    O(1)    O(1)    O(1)    O(1)          isEmpty()    O(1)    O(1)    O(1)    O(1)          isFull()    O(1)    O(1)    N/A    N/A          deleteQueue()    O(1)    O(1)    O(1)    O(1)      Tree: Binary TreeThe table below shows the implementation between Array and Linked List for Binary Tree.           Operations    using Array    using Linked List          Time Complexity    Space Complexity    Time Complexity    Space Complexity              createTree()    O(1)    O(n)    O(1)    O(1)          insert()    O(1)    O(1)    O(n)    O(n)          delete()    O(n)    O(1)    O(n)    O(n)          search()    O(n)    O(1)    O(n)    O(n)          traverse()    O(n)    O(1)    O(n)    O(n)          deleteTree()    O(1)    O(1)    O(1)    O(1)       Using Linked List is more space efficient as creating a binary tree is O(1) as compared to Array which is O(n), hence, the preferred implementation is Linked List. Binary Search Tree &amp; AVL Tree          Operations    Binary Search Tree    AVL Tree          Avg.     Worst          Time Complexity    Space Complexity    Time Complexity    Space Complexity    Time Complexity    Space Complexity              createTree()    O(1)    O(n)    O(1)    O(1)    O(1)    O(1)          search()    O(log n)    O(log n)    O(n)    O(n)    O(log n)    O(log n)          traverse()    O(n)    O(n)    O(n)    O(n)    O(n)    O(n)          insertNode()    O(log n)    O(log n)    O(n)    O(n)    O(log n)    O(log n)          deleteNote()    O(log n)    O(log n)    O(n)    O(n)    O(log n)    O(log n)          deleteTree()    O(1)    O(1)    O(1)    O(1)    O(1)    O(1)      Heap (Using Array):           Operations    Time Complexity    Space Complexity              createHeap()    O(1)    O(n)          peekTopOfHeap()    O(1)    O(1)          sizeOfHeap()    O(1)    O(1)          insertValue()    O(log n)    O(log n)          extractMin() / extractMax()    O(log n)    O(log n)          deleteHeap()    O(1)    O(1)      Hash Table:           Operations    Time Complexity    Space Complexity          Avg.     Worst              search()    O(1)    O(n)    O(n)          insert()    O(1)    O(n)    O(n)          delete()    O(1)    O(n)    O(n)      Graphs: Common Operations          Operations    Time Complexity    Space Complexity              Breadth First Search    O(V + E)    O(E)          Depth First Search    O(E + V)    O(V)          Topological sort    O(E + V)    O(E + V)      Common Algorithms for Graph problems          Operations    Single Source Shortest Path    All Pair Shortest Path          Time Complexity    Space Complexity    Time Complexity    Space Complexity              Breadth First Search    O(V2)    O(E)    O(V3)    O(EV)          Dijkstra    O(V2)    O(V)    O(V3)    O(EV)          Bellman Ford    O(VE)    O(V)    O(VE2)    O(V2)          Floyd Warshall    N/A    N/A    O(V3)    O(V2)      Sorting Algorithms:           Types    Time Complexity    Space Complexity    Stable              Bubble sort    O(n2)    O(1)    Yes          Selection sort    O(n2)    O(1)    No          Insertion sort    O(n2)    O(1)    Yes          Bucket sort    O(n log n)    O(n)    Yes*          Merge sort    O(n log n)    O(n)    Yes          Quick sort    O(n log n)    O(n)*    No          Heap sort    O(n log n)    O(1)    No      How to find time complexity: This section will show how to calculate the time complexity of iterative vs recursive algorithms. Iterative: def findBiggestNum(arr): biggestNum = arr[0]      # ------------------O(1) for i in range(0, len(arr)):  # ---------O(n)--|--O(n)  if arr[i] &gt; biggestNum:   # O(1)--|--O(1)--|   biggestNum = arr[i]    # O(1)--| return biggestNum       # ------------------O(1)Time complexity: O(1) + O(n) + O(1) = O(n) Recursive #1: highest = 0def findBiggestNum(arr, n):     # ----T(n) if n == -1:            # ----O(1) ---|--- Base condition  return highest         # ----O(1) ---| else:               # ----O(1)  if arr[n] &gt; highest:      # ----O(1) return findBiggestNum(arr, n-1)  # ----T(n-1)Equation 1: T(n) = O(1) + T(n-1)  O(1) + O(1) + O(1) + O(1) = O(1) Base Condition: T(-1) = O(1)  if n == -1, recursion will end, so if the recursion method = T(n), we replace n to -1 to get T(-1), and since base condition = O(1), T(-1) = O(1) Equation 2: T(n-1) = O(1) + T((n-1)-1) Equation 3: T(n-2) = O(1) + T((n-2)-1) T(n) = 1 + T(n-1)   = 1 + (1 + T((n-1)-1)) // substitute `Equation 2`   = 2 + T(n-2)   = 2 + (1 + T((n-2)-1)) // substitute `Equation 3`   = 3 + T(n-3)      // notice the pattern, substitue with k   = k + T(n-k)   = (n+1) + T(n-(n+1))  // attempt to make it T(-1) since it is the base condition, replace k with n+1   = n + 1 + T(-1)   = n + 1 + 1      // T(-1) = 1   = O(n)Recursive #2: def search(num, arr, start, end):    # ----T(n) if start &lt;= end:           # ----O(1) ---|--- Base Condition  if arr[start] == num:        # ----O(1) ---|   return start           # ----O(1) ---|  else:                # ----O(1) ---|   return False           # ----O(1) ---| mid = find_mid(arr, start, end)    # ----O(1) if mid &gt; num:             # ----O(1)  search(num, arr, start, mid)    # ----T(n/2) elif mid &lt; num:            # ----O(1)  search(num, arr, mid, end)     # ----T(n/2) elif mid == num:           # ----O(1)  return mid             # ----O(1)Equation 1: T(n) = T(n/2) + 1 Base Condition: T(1) = O(1)  If the array is of size 1, we can perform it in constant time Equation 2: T(n/2) = T(n/4) + 1 Equation 3: T(n/4) = T(n/8) + 1 T(n) = T(n/2) + 1   = T(n/4) + 1 + 1    // substitue `Equation 2`   = T(n/4) + 2   = T(n/8) + 1 + 2    // substitue `Equation 3`   = T(n/8) + 3   = T(n/2^k) + k     // notice the pattern, substitue with k   = T(1) + log n     // attempt to make it T(1) snce it is the base condition, see below how n/2^k = 1 = k   = 1 + log n   = O(log n) [n/2^K = 1] =&gt; [n = 2^K] =&gt; [k = log n] "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><span class='body'>"+ body +"</span><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-primary btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><small><span class='body'>"+ body +"</span><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});